// Code generated by "gen-int -t int8 -o convert/int8.go"; DO NOT EDIT.
package convert

import (
	"errors"
	"strconv"
)

func ToInt8(v interface{}) (int8, error) {
	if v == nil {
		return 0, ErrNil
	}
	switch vt := v.(type) {

	case int8:
		return vt, nil
	case *int8:
		if vt == nil {
			return 0, ErrNil
		}
		return *vt, nil

	case int16:
		if vt < int16(minInt8) || int16(maxInt8) < vt {
			return 0, &RangeError{"int16", "int8", vt}
		}
		return int8(vt), nil
	case *int16:
		if vt == nil {
			return 0, ErrNil
		}
		if *vt < int16(minInt8) || int16(maxInt8) < *vt {
			return 0, &RangeError{"*int16", "int8", *vt}
		}
		return int8(*vt), nil

	case int32:
		if vt < int32(minInt8) || int32(maxInt8) < vt {
			return 0, &RangeError{"int32", "int8", vt}
		}
		return int8(vt), nil
	case *int32:
		if vt == nil {
			return 0, ErrNil
		}
		if *vt < int32(minInt8) || int32(maxInt8) < *vt {
			return 0, &RangeError{"*int32", "int8", *vt}
		}
		return int8(*vt), nil

	case int64:
		if vt < int64(minInt8) || int64(maxInt8) < vt {
			return 0, &RangeError{"int64", "int8", vt}
		}
		return int8(vt), nil
	case *int64:
		if vt == nil {
			return 0, ErrNil
		}
		if *vt < int64(minInt8) || int64(maxInt8) < *vt {
			return 0, &RangeError{"*int64", "int8", *vt}
		}
		return int8(*vt), nil

	case int:
		if vt < int(minInt8) || int(maxInt8) < vt {
			return 0, &RangeError{"int", "int8", vt}
		}
		return int8(vt), nil
	case *int:
		if vt == nil {
			return 0, ErrNil
		}
		if *vt < int(minInt8) || int(maxInt8) < *vt {
			return 0, &RangeError{"*int", "int8", *vt}
		}
		return int8(*vt), nil

	case uint8:
		if uint8(maxInt8) < vt {
			return 0, &RangeError{"uint8", "int8", vt}
		}
		return int8(vt), nil
	case *uint8:
		if vt == nil {
			return 0, ErrNil
		}
		if uint8(maxInt8) < *vt {
			return 0, &RangeError{"*uint8", "int8", *vt}
		}
		return int8(*vt), nil

	case uint16:
		if uint16(maxInt8) < vt {
			return 0, &RangeError{"uint16", "int8", vt}
		}
		return int8(vt), nil
	case *uint16:
		if vt == nil {
			return 0, ErrNil
		}
		if uint16(maxInt8) < *vt {
			return 0, &RangeError{"*uint16", "int8", *vt}
		}
		return int8(*vt), nil

	case uint32:
		if uint32(maxInt8) < vt {
			return 0, &RangeError{"uint32", "int8", vt}
		}
		return int8(vt), nil
	case *uint32:
		if vt == nil {
			return 0, ErrNil
		}
		if uint32(maxInt8) < *vt {
			return 0, &RangeError{"*uint32", "int8", *vt}
		}
		return int8(*vt), nil

	case uint64:
		if uint64(maxInt8) < vt {
			return 0, &RangeError{"uint64", "int8", vt}
		}
		return int8(vt), nil
	case *uint64:
		if vt == nil {
			return 0, ErrNil
		}
		if uint64(maxInt8) < *vt {
			return 0, &RangeError{"*uint64", "int8", *vt}
		}
		return int8(*vt), nil

	case uint:
		if uint(maxInt8) < vt {
			return 0, &RangeError{"uint", "int8", vt}
		}
		return int8(vt), nil
	case *uint:
		if vt == nil {
			return 0, ErrNil
		}
		if uint(maxInt8) < *vt {
			return 0, &RangeError{"*uint", "int8", *vt}
		}
		return int8(*vt), nil

	case string:
		n, err := strconv.ParseInt(vt, 10, 8)
		if err != nil {
			if errors.Is(err, strconv.ErrRange) {
				err = &RangeError{"string", "int8", vt}
			}
			return 0, err
		}
		r, err := ToInt8(n)
		if err, ok := err.(*RangeError); ok && err != nil {
			err.from = "string"
		}
		return r, err
	case *string:
		if vt == nil {
			return 0, ErrNil
		}
		n, err := strconv.ParseInt(*vt, 10, 8)
		if err != nil {
			if errors.Is(err, strconv.ErrRange) {
				err = &RangeError{"*string", "int8", *vt}
			}
			return 0, err
		}
		r, err := ToInt8(n)
		if err, ok := err.(*RangeError); ok && err != nil {
			err.from = "*string"
		}
		return r, err

	}
	return 0, ErrNoNumConvert
}

func ToInt8P(v interface{}) (*int8, error) {
	if v == nil {
		return nil, nil
	}
	switch vt := v.(type) {

	case int8:
		return &vt, nil
	case *int8:
		return vt, nil

	case int16:
		if vt < int16(minInt8) || int16(maxInt8) < vt {
			return nil, &RangeError{"int16", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *int16:
		if vt == nil {
			return nil, nil
		}
		if *vt < int16(minInt8) || int16(maxInt8) < *vt {
			return nil, &RangeError{"*int16", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case int32:
		if vt < int32(minInt8) || int32(maxInt8) < vt {
			return nil, &RangeError{"int32", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *int32:
		if vt == nil {
			return nil, nil
		}
		if *vt < int32(minInt8) || int32(maxInt8) < *vt {
			return nil, &RangeError{"*int32", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case int64:
		if vt < int64(minInt8) || int64(maxInt8) < vt {
			return nil, &RangeError{"int64", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *int64:
		if vt == nil {
			return nil, nil
		}
		if *vt < int64(minInt8) || int64(maxInt8) < *vt {
			return nil, &RangeError{"*int64", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case int:
		if vt < int(minInt8) || int(maxInt8) < vt {
			return nil, &RangeError{"int", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *int:
		if vt == nil {
			return nil, nil
		}
		if *vt < int(minInt8) || int(maxInt8) < *vt {
			return nil, &RangeError{"*int", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case uint8:
		if uint8(maxInt8) < vt {
			return nil, &RangeError{"uint8", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *uint8:
		if vt == nil {
			return nil, nil
		}
		if uint8(maxInt8) < *vt {
			return nil, &RangeError{"*uint8", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case uint16:
		if uint16(maxInt8) < vt {
			return nil, &RangeError{"uint16", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *uint16:
		if vt == nil {
			return nil, nil
		}
		if uint16(maxInt8) < *vt {
			return nil, &RangeError{"*uint16", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case uint32:
		if uint32(maxInt8) < vt {
			return nil, &RangeError{"uint32", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *uint32:
		if vt == nil {
			return nil, nil
		}
		if uint32(maxInt8) < *vt {
			return nil, &RangeError{"*uint32", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case uint64:
		if uint64(maxInt8) < vt {
			return nil, &RangeError{"uint64", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *uint64:
		if vt == nil {
			return nil, nil
		}
		if uint64(maxInt8) < *vt {
			return nil, &RangeError{"*uint64", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case uint:
		if uint(maxInt8) < vt {
			return nil, &RangeError{"uint", "*int8", vt}
		}
		casted := int8(vt)
		return &casted, nil
	case *uint:
		if vt == nil {
			return nil, nil
		}
		if uint(maxInt8) < *vt {
			return nil, &RangeError{"*uint", "*int8", *vt}
		}
		casted := int8(*vt)
		return &casted, nil

	case string:
		n, err := strconv.ParseInt(vt, 10, 8)
		if err != nil {
			if errors.Is(err, strconv.ErrRange) {
				err = &RangeError{"string", "*int8", vt}
			}
			return nil, err
		}
		r, err := ToInt8P(n)
		if err, ok := err.(*RangeError); ok && err != nil {
			err.from = "string"
		}
		return r, err
	case *string:
		if vt == nil {
			return nil, nil
		}
		n, err := strconv.ParseInt(*vt, 10, 8)
		if err != nil {
			if errors.Is(err, strconv.ErrRange) {
				err = &RangeError{"*string", "*int8", *vt}
			}
			return nil, err
		}
		r, err := ToInt8P(n)
		if err, ok := err.(*RangeError); ok && err != nil {
			err.from = "*string"
		}
		return r, err

	}
	return nil, ErrNoNumConvert
}
